\chapter{Introduction}
\label{chap:introduction}
The movement to smart mobile connected devices which consolidate functions of traditionally separate devices is driving innovation in System-on-chips (SoCs).  One of the innovations helping to meet the current needs of SoCs is the integration of larger memory with the processor.  As the need for memory has increased, SoCs have moved from logic dominant chips to memory dominant chips.  In fact, \cite{1327984} estimates 94\% of the SoC will be dedicated to memory by 2014.  

Because embedded memories are designed with aggressive design rules to increase the density of transistors per area, they are more prone to manufacturing defects that negatively affect the overall chip yield.  Testing memory to identify faulty blocks is critical to increase and maintain acceptable yield \cite{1395663}. 
A built-in self-test (BIST) has previously been used to test logical elements of the chip, but now have been adapted to test memory as well.  The density of memory and difficulty in accessing all signals has driven the growth of memory built-in self-test (MBIST) as the only practical and cost-effect solution for embedded SoC memories \cite{5875994}.  

As not all fault models can always be predicted for a new product, programmable MBIST (PMBIST) designs allow developers to address fault detection, create efficient algorithms, and overcome challenges presented by new technology.  Conversely, a non-programmable MBIST requires the designer to correctly predict the fault models to be tested, but changes to the design or mask typically requires another tape-out and can be quite expensive.  Because of this, the programmable MBIST has gained popularity amongst memory designers. 

The most common memory test today is the March test because its structured and repetitive algorithms can be applied very easily to the symmetric nature of memory cells \cite{1675150}.  The design presented in \cite{1584083} primarily uses the March test to verify the integrity of the memory.  In general, there are three components of memory tests: the test algorithm or operations in each cell; the data; and the memory address sequence \cite{5993815}.  

The PMBIST design presented in \cite{1584083} will be used as the base design and is intended to provide an area efficient design with good flexibility on algorithm and test data programming.  This report proposes improvements to the design by providing programmability to the address order and counting method. The previous design uses a linear counter and pseudo-random counter to sequence through memory addresses.  This allows the BIST to run March algorithms, but another algorithm, Moving Inversion (MOVI) cannot be run because it requires 2\textsuperscript{i} address counting method.   MOVI is popular industry for its ability to detect read and write disturbance while also allowing for determination of the best and worst case memory access times \cite{VanDeGoor1991}.  This project adds the 2\textsuperscript{i} counting method along with Gray coding and Address Compliment to integrate common industry test addressing sequences into the BIST. 

In addition, this paper will show a reduction of area can be achieved by introducing a dynamic pattern generation block to replace the auxiliary memory used to store neighborhood pattern-sensitive fault (NPSF) backgrounds.  In the base design, the data pattern for auxiliary memory can initialized through a scan mechanism \cite{748806}, but relying solely on scan to load data patterns can be time consuming for serial BIST schemes.  Additionally, the MOVI fault model requires an NPSF data background of Type 1 to be effective.  Because of this, this report integrates an NPSF data background generator to remove the scan delay.  This provides faster access time and potentially removes the need for an auxiliary memory thus speeding up test time and saving area.  In achieving these design goals, this report will show enhancements to the \cite{1584083} design in two of the three memory test components.

This paper is divided into five chapters.
Chapter 1 offers motivation for this project and supplies definitions for common terminology.  Chapter 2 provides background information on the memory faults, current memory testing algorithms and designs to address some of the challenges of memory testing.  Chapter 3 presents details of the design proposed in this report and chapter 4 follows with testing results and comparisons to other designs.
Finally, chapter 5 concludes the report.  

\input{tex/chapter-introduction/section-terminology}


