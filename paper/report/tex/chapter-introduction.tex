\chapter{Introduction}
\label{chap:introduction}
The movement to smart mobile connected devices which consolidate functions of traditionally separate devices is driving innovation in System-on-chips (SoCs).  One of the innovations helping to meet the current needs of SoCs is the integration of larger memory with the processor.  As the need for memory has increased, SoCs have moved from logic dominant chips to memory dominant chips.  In fact, it is estimated 94\% of the SoC will be dedicated to memory by 2014 \cite{1327984}.

Because embedded memories are designed with aggressive design rules to increase the density of transistors, they are more prone to manufacturing defects that negatively affect the overall chip yield.  Testing memories to identify faulty blocks is critical to increasing and maintaining acceptable yields \cite{1395663}. 
A built-in self-test (BIST) has previously been used to test logical elements of the chip, and now, has been adapted to test memory as well.  The density of memory and difficulty in accessing all signals has driven the growth of memory BIST (MBIST) as the only practical and cost-effective solution for embedded SoC memories \cite{5875994}.  

As not all fault models can always be predicted for a new product, programmable MBIST (PMBIST) designs allow developers to update fault detection, create more efficient algorithms, and overcome challenges presented by new technology.  Conversely, a non-programmable MBIST requires designers to correctly predict the fault models to be tested, but changes to the design or mask typically require another tape-out and can be quite expensive.  Because of this, the programmable MBIST has gained popularity amongst memory designers. 

The most common memory test today is the March test because its structured and repetitive algorithms can be applied very easily to the symmetric nature of memory cells \cite{1675150}.  The design proposed in \cite{1584083} primarily uses the March test to verify the integrity of the memory.  In general, there are three components of memory tests: the test algorithm or operations in each cell; the data; and the memory address sequence \cite{5993815}.  

The PMBIST design presented in \cite{1584083} is intended to provide an area efficient design with good flexibility with algorithm and test data programming and will be used as the base design. This report proposes enhancements to the design by providing programmability to the address order and counting method.  

The base design uses a linear counter and pseudo-random counter to sequence through memory addresses.  This allows the BIST to run March algorithms, but another algorithm, Moving Inversion (MOVI) cannot be run because it requires 2\textsuperscript{\textit{i}} address counting method.   MOVI is popular in industry for its ability to detect read and write disturbance while also allowing for determination of the best and worst case memory access times \cite{VanDeGoor1991}.  This project adds the 2\textsuperscript{\textit{i}} counting method.  In addition, it will also add Gray coding and Address Complement to integrate more common industry test addressing sequences into the BIST. 

In addition, this paper will show a reduction of area can be achieved by introducing a dynamic pattern generation block to replace the auxiliary memory used to store neighborhood pattern-sensitive fault (NPSF) backgrounds.  In the base design, the data pattern for auxiliary memory can be initialized through a scan mechanism \cite{748806}, but relying solely on scan to load data patterns can be time-consuming for serial BIST schemes.  Additionally, the MOVI fault model requires an NPSF data background of Type 1 to be effective.  Because of this, this report integrates an NPSF data background generator to remove the scan delay.  This provides faster access time and potentially removes the need for an auxiliary memory thus speeding up test time and saving area.  In achieving these design goals, this report will show enhancements to the base design in two of the three memory test components.

This paper is divided into five chapters.
Chapter 1 offers motivation for this project and supplies definitions for common terminology.  Chapter 2 provides background information on the memory faults, current memory testing algorithms and designs to address some of the challenges of memory testing.  Chapter 3 presents details of the design proposed in this report and Chapter 4 follows with testing results and comparisons of the area.
Finally, Chapter 5 concludes the report.  

\input{tex/chapter-introduction/section-terminology}


