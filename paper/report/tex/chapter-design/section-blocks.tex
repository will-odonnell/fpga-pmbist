\section{Major Blocks}
\label{sect:bg-blocks}
The proposed design is comprised of four major blocks: the cycle controller, address and operator generation block, data generation and comparison block and the external connections.

\subsection{Cycle Controller}
The cycle controller determines which march operation should execute on the current address.  When all march operations have completed on the current address, the cycle controller generates a signal that allows the address counter to move to the next test address.  The cycle controller then resets the march operation pointer to the first operation for the next address.   

\subsubsection{Control Mux}
The control mux receives all the operation and polarity signals from the instruction register.  Using the cycle counter's output as the mux control signal, the control mux selects the operation and polarity signal corresponding to the current cycle and outputs them to the operation formatting block and control register.  

\subsubsection{Cycle Counter}
The cycle counter increments the count for the march operation to execute.  The output of the cycle counter corresponds to the active march operation.  The cycle counter is incremented by the clock signal and can be reset by a TS signal or when the current march sequence has completed for the current memory address. 

\subsubsection{Cycle Comparison}
The cycle comparison unit compares the current cycle to the NO field of the instruction register.  When the cycle counter matches the NO field, the comparison block generates an active high signal that is stored in the cycle controller's local flip-flop.  The signal is also sent to the instruction register hold logic block.  

\subsection{Address and Operator Generation}
The memory address to test and memory control signals are generated by the address and operation block.  The address decode block is used to generate the instruction register hold signal.  The hold signal maintains the instruction register's data until the current march sequence has completed for all memory address.  

\subsubsection{Address Counter}
The address counter indicates the memory address to test.  The direction of the address order can be programmed to increment or decrement through memory.  The order of addresses is also programmable: numerical from bottom or top of memory, psuedo-random sequence using LFSR, Y-pattern, Z-pattern, X-pattern through memory.
 
\subsubsection{Address Decode Logic}
The address decode logic block determines if the address generated by the address counter is the last up (LU) or last down (LD) memory address for the current march sequence.  The decode logic uses the signals from the address programmer block to determine whether the sequence direction is up or down.   

\subsubsection{Operator Formatting and Control Register}
The operation signals from the instruction register do not necessarily need to match the memory's control signals.  The operation formatting block can be used to translate the instruction register's operation code to the memory controller's signals such as write/read, enable and reset.  The output of the format block is stored in the opratoin control register which is then sent to the MUT.

\subsection{Data Generation and Compare}
Data can come from the instruction register or the auxillary memory.  For memory data patterns, the data from the instruction register is selected and writtento memory.  Depending on the polarity signal, the data can be unmodified or inverted.  For the NPSF patterns, the data from the auxillary memory is selected.  
\subsubsection{Data Comparator}
Each read march element is checked with the data comparator.  The comparator accepts as inputs the TDS bus and the output of the MUT.  If the MUT output mathces the TDS value, a pass signal is generated.  If there is any discrepency, the fail signal is generated.  

\subsubsection{Polarity and Data Register}
The polarity signal from the current march operation is used to invert the data.  If the polarity signal is false (0), the data is unmodified and stored to the data register.  If the polarity signal is true (1), the data is inverted, then stored in the data register.  

\subsection{External Connections}
Intergration with the MUT and scan-path requires a few external connections.  The scan-path writes data to the instruction register for the test.  The MUT receives address, data and control signals from the memory BIST.

\subsubsection{Scan-Path Connection}
The scan-path receives data serially for the memory BIST.  The scan-path signals correspond to the instruction register fields.  When the scan-in data has been clocked into place, the instruction register will latch the data and begin its test.  

\subsubsection{Memory Under Test Connections}
The MUT connects to the MBIST through the test busses.  The connections provides the data, control signals and address to the memory and are connected to the memory input pins.  

\paragraph{Test Address Signals}
The test address signals (TAS) compose the memory address currently on interest to the test.  They can point to the read address for a comparison or check or the write address to store new data.

\paragraph{Test Control Signals}
The test control signals (TCS) are generated from the instruction register's operation field.  The signals are formatted to work with the MUT.  The opcode is translated to the memory control signals such as read/write, reset and enable.  

\paragraph{Test Data Signals}
The test data signals (TDS) contain the data to be stored in memory.  These signals are connected to the MUT's data input pins and the data comparator's input pins.  They are driven from the data register.  When an auxillary memory is used, the data pins are driven from the outputs of the auxiallary memory.

\subsection{Auxillary Memory}
The auxillary memory is used for storing the NPSF patterns to be written to memory.  

